<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metro Mogul: Real Estate Tycoon v1.2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #2c2c2e;
            --panel-bg: #e0e0e0;
            --highlight: #4a90e2;
            --text-color: #1a1a1a;
            --success: #2ecc71;
            --danger: #e74c3c;
            --warning: #f1c40f;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* UI Layout */
        #game-container {
            display: flex;
            width: 100%;
            height: 100%;
            max-width: 1200px;
            background: #111;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Main Menu Overlay */
        #main-menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #main-menu {
            background: var(--panel-bg);
            border: 4px solid #444;
            box-shadow: 10px 10px 0px #888;
            padding: 30px;
            text-align: center;
            width: 400px;
        }

        #main-menu h1 {
            color: #4a69bd;
            font-size: 3rem;
            margin-bottom: 5px;
            border-bottom: 2px solid #888;
            padding-bottom: 10px;
        }

        #main-menu p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        #main-menu button {
            margin: 10px 0;
            padding: 15px 20px;
            font-size: 1.3rem;
        }

        /* Sidebar (Stats & Controls) */
        #sidebar {
            width: 320px;
            background: #d4d4d4;
            border-right: 4px solid #888;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            position: relative;
            z-index: 10;
        }

        .panel {
            background: #fff;
            border: 2px solid #444;
            box-shadow: 4px 4px 0px #888;
            padding: 10px;
            margin-bottom: 15px;
        }

        .panel-header {
            background: #4a69bd;
            color: white;
            padding: 5px;
            margin: -10px -10px 10px -10px;
            text-align: center;
            font-size: 1.2rem;
            border-bottom: 2px solid #444;
        }

        /* Main View (Canvas) */
        #viewport {
            flex-grow: 1;
            position: relative;
            background-color: #5d9e57;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* HUD Overlay on Canvas */
        #hud-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 20px;
            border-radius: 20px;
            border: 2px solid #fff;
            font-size: 1.5rem;
            pointer-events: none;
            display: flex;
            gap: 20px;
        }

        #time-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        #view-controls {
            position: absolute;
            top: 60px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        #zoom-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .speed-btn, .view-btn {
            background: rgba(0,0,0,0.8);
            color: white;
            border: 2px solid white;
            padding: 5px 10px;
            font-family: 'VT323';
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: none;
            transition: 0.1s;
        }
        .speed-btn:hover, .view-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .speed-btn.active, .view-btn.active {
            background: #fff;
            color: #000;
        }

        #ticker {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #000;
            color: #0f0;
            padding: 5px;
            font-size: 1.2rem;
            white-space: nowrap;
            overflow: hidden;
            border-top: 2px solid #fff;
            z-index: 20;
        }

        /* Controls */
        button {
            background: #f1f2f6;
            border: 2px solid #444;
            box-shadow: 2px 2px 0px #000;
            color: #333;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            padding: 5px 10px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 5px;
            transition: transform 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        button.primary { background: #7bed9f; }
        button.danger { background: #ff6b6b; color: white; }
        button.warning { background: #f1c40f; }
        button.service-active { background: #4a90e2; color: white; }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            color: #666;
            opacity: 0.7;
        }

        .locked-hint {
            color: #d63031;
            font-size: 0.8rem;
            display: block;
            margin-top: -5px;
            margin-bottom: 5px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 1.1rem;
        }

        .trend-up { color: #2ecc71; }
        .trend-down { color: #e74c3c; }
        .trend-flat { color: #f1c40f; }

        #achievement-popup {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: #f1c40f;
            color: #000;
            padding: 20px;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            text-align: center;
            display: none;
            animation: popIn 0.5s ease-out;
            z-index: 50;
        }
        @keyframes popIn {
            0% { transform: translateX(-50%) scale(0); }
            80% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }

    </style>
</head>
<body>

<div id="game-container">
    <!-- Achievement Popup -->
    <div id="achievement-popup">
        <h2 style="margin:0">ACHIEVEMENT UNLOCKED!</h2>
        <p id="ach-text" style="font-size:1.5rem; margin:10px 0;">Millionaire!</p>
        <small>Bonus: $5,000</small>
    </div>

    <!-- Main Menu Overlay -->
    <div id="main-menu-overlay">
        <div id="main-menu" class="panel">
            <h1>METRO MOGUL</h1>
            <p>v1.2 - Zoom & Transit</p>
            <button class="primary" id="btn-start-new" onclick="Game.startNewGame()">START NEW GAME</button>
            <button id="btn-load-game" onclick="Game.loadGame()">LOAD GAME</button>
            <p style="font-size:0.9rem; margin-top: 30px; color:#666;">Use Scroll Wheel to Zoom.<br>WASD or Drag to Pan.</p>
        </div>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
        <div class="panel">
            <div class="panel-header">METRO MOGUL</div>
            <div class="stat-row"><span>Cash:</span> <span id="ui-cash" style="color:green">$0</span></div>
            <div class="stat-row"><span>Loans:</span> <span id="ui-loans" style="color:red">$0</span></div>
            <div class="stat-row"><span>Net Worth:</span> <span id="ui-networth">$0</span></div>
            <div class="stat-row"><span>Income/wk:</span> <span id="ui-income">$0</span></div>
            <div class="stat-row"><span>Date:</span> <span id="ui-date">Week 1, Year 1</span></div>
            <div class="stat-row"><span>Market:</span> <span id="ui-market">Normal</span></div>
            <div class="stat-row"><span>Weather:</span> <span id="ui-weather">Clear</span></div>
            <div style="text-align:center; margin-top:5px;">
                <small style="color:#666;" id="ui-save-status">Auto-saving...</small>
                <button onclick="Game.resetGame()" class="danger" style="font-size:0.9rem; margin-top:5px;">Quit & Reset Game</button>
            </div>
        </div>

        <!-- City Services Panel -->
        <div class="panel">
            <div class="panel-header">City Services (5% Income Tax)</div>
            <div id="services-controls">
                <button id="service-police" onclick="Game.actions.toggleService('police')"
                        class="service-toggle">üëÆ‚Äç‚ôÇÔ∏è Police ($500/wk)</button>
                <button id="service-fire" onclick="Game.actions.toggleService('fire')"
                        class="service-toggle">üöí Fire ($300/wk)</button>
            </div>
        </div>

        <!-- Bank Panel -->
        <div class="panel">
            <div class="panel-header">City Bank (5% Interest)</div>
            <div style="display:flex; justify-content:space-between; gap:5px;">
                <button class="primary" onclick="Game.actions.takeLoan()">Borrow $10k</button>
                <button class="warning" onclick="Game.actions.repayLoan()">Repay $10k</button>
            </div>
        </div>

        <!-- Dynamic Action Panel -->
        <div class="panel" id="action-panel">
            <div class="panel-header">Selection</div>
            <div id="selection-content">
                <p style="text-align:center; color:#666;">Select a tile to interact.</p>
            </div>
        </div>

        <!-- Build Menu (Hidden by default) -->
        <div class="panel" id="build-menu" style="display:none;">
            <div class="panel-header">Construction</div>
            <div id="build-buttons"></div>
            <hr>
            <button class="danger" onclick="Game.ui.closeBuildMenu()">Cancel</button>
        </div>

        <div class="panel">
            <div class="panel-header">Log</div>
            <div id="game-log" style="height: 100px; overflow-y: auto; font-size: 0.9rem;">
                <div style="color:#666;">Welcome to Metro Mogul!</div>
            </div>
        </div>
    </div>

    <!-- Viewport -->
    <div id="viewport">
        <canvas id="city-canvas"></canvas>
        <div id="hud-top">
            <span id="hud-money">$100,000</span>
        </div>
        <div id="time-controls">
            <button class="speed-btn" id="btn-pause" onclick="Game.setSpeed(0)">‚è∏</button>
            <button class="speed-btn active" id="btn-normal" onclick="Game.setSpeed(1)">‚ñ∂</button>
            <button class="speed-btn" id="btn-fast" onclick="Game.setSpeed(4)">‚è©</button>
        </div>
        <div id="view-controls">
            <div id="zoom-controls">
                <button class="view-btn" onclick="Game.adjustZoom(-0.2)">-</button>
                <button class="view-btn" onclick="Game.resetZoom()">1:1</button>
                <button class="view-btn" onclick="Game.adjustZoom(0.2)">+</button>
            </div>
            <button class="view-btn" id="btn-view-appeal" onclick="Game.toggleAppealView()">Appeal Map</button>
        </div>
        <div id="ticker">News: Real Estate Market is currently stable...</div>
    </div>
</div>

<script>
/**
 * Metro Mogul - Game Logic v1.2
 * Updates: Zoom, Day/Night, Weather, Metro, Achievements, Selling
 */

const CONSTANTS = {
    TILE_SIZE: 64,
    GRID_WIDTH: 20,
    GRID_HEIGHT: 15,
    BASE_TICK_RATE: 2000,
    CITY_TAX_RATE: 0.05,
    SERVICE_COSTS: {
        police: 500,
        fire: 300
    },
    COLORS: {
        water: '#5dade2',
        road: '#7f8c8d',
        grass_suburb: '#78c470',
        grass_downtown: '#5d9e57',
        grass_industrial: '#95a5a6',
        selected: 'rgba(255, 255, 0, 0.4)',
        hover: 'rgba(255, 255, 255, 0.2)',
        rival: '#555',
        rivalBuilding: '#333'
    },
    BUILDING_TYPES: {
        residential: { id:'residential', name: "House", cost: 5000, baseRent: 150, color: '#e74c3c', maintenance: 20, icon: 'üè†', type:'res', unlock: 0, allowed: ['suburbs', 'downtown'] },
        commercial: { id:'commercial', name: "Shop", cost: 12000, baseRent: 400, color: '#3498db', maintenance: 80, icon: 'üè™', type:'com', unlock: 0, allowed: ['suburbs', 'downtown'] },
        park: { id:'park', name: "Park", cost: 2000, baseRent: 0, color: '#2ecc71', maintenance: 10, icon: 'üå≥', appealRadius: 3, appealBonus: 15, type:'amenity', unlock: 0, allowed: ['suburbs', 'downtown', 'industrial'] },
        apartment: { id:'apartment', name: "Apts", cost: 25000, baseRent: 1200, color: '#d35400', maintenance: 300, icon: 'üè¢', type:'res_high', unlock: 100000, allowed: ['downtown'] },
        office: { id:'office', name: "Office", cost: 50000, baseRent: 3000, color: '#2c3e50', maintenance: 800, icon: 'üèôÔ∏è', type:'com_high', unlock: 250000, allowed: ['downtown'] },
        factory: { id:'factory', name: "Factory", cost: 15000, baseRent: 600, color: '#555', maintenance: 50, icon: 'üè≠', type:'ind', unlock: 50000, appealBonus: -20, allowed: ['industrial'] },
        metro: { id:'metro', name: "Metro", cost: 30000, baseRent: 0, color: '#8e44ad', maintenance: 400, icon: 'üöá', type:'transport', unlock: 150000, allowed: ['suburbs', 'downtown'] }
    },
    ACHIEVEMENTS: [
        { id: 'start', name: "Landlord", threshold: 10000, reward: 1000, desc: "Net Worth > $10k" },
        { id: 'mid', name: "Tycoon", threshold: 100000, reward: 5000, desc: "Net Worth > $100k" },
        { id: 'high', name: "Mogul", threshold: 500000, reward: 25000, desc: "Net Worth > $500k" },
        { id: 'ultra', name: "Empire", threshold: 1000000, reward: 100000, desc: "Net Worth > $1M" }
    ]
};

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('city-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = 0;
        this.height = 0;

        // Game State
        this.cash = 0;
        this.loan = 0;
        this.netWorth = 0;
        this.week = 1;
        this.year = 1;
        this.marketTrend = 'Normal';
        this.marketIndex = 100;
        this.marketMultiplier = 1.0;
        this.selectedTile = null;
        this.hoverTile = null;
        this.speed = 0;
        this.lastTickTime = 0;
        this.floatingTexts = [];
        this.viewMode = 'normal';
        this.services = { police: false, fire: false };
        this.grid = [];
        this.achievementsUnlocked = [];

        // New State Variables
        this.weather = 'clear'; // 'clear' or 'rain'
        this.weatherTimer = 0;
        this.dayCycle = 0; // 0-100 (0-75 day, 75-100 night)

        // Camera & Zoom
        this.camera = { x: 0, y: 0 };
        this.zoom = 1.0;
        this.isDragging = false;
        this.lastMouse = { x: 0, y: 0 };

        this.resize();
        this.setupEvents();

        this.ui = new UIManager(this);
        this.updateLoadButton();
        this.setSpeed(0);
        requestAnimationFrame((t) => this.gameLoop(t));
        this.ui.updateStats();
    }

    updateLoadButton() {
        const loadButton = document.getElementById('btn-load-game');
        if (localStorage.getItem('metroMogulSave')) {
            loadButton.disabled = false;
            loadButton.textContent = "LOAD GAME (Saved)";
        } else {
            loadButton.disabled = true;
            loadButton.textContent = "LOAD GAME (No Save)";
        }
    }

    initGrid() {
        for (let x = 0; x < CONSTANTS.GRID_WIDTH; x++) {
            this.grid[x] = [];
            for (let y = 0; y < CONSTANTS.GRID_HEIGHT; y++) {
                let type = 'grass';
                let zone = 'suburbs';
                let basePrice = 2000;

                // 1. Water Front (Bottom Edge)
                if (y >= CONSTANTS.GRID_HEIGHT - 3) {
                    type = 'water';
                    zone = 'waterfront';
                    basePrice = 0;
                }

                // 2. Downtown (Center/Top Right)
                if (x >= CONSTANTS.GRID_WIDTH - 8 && y < CONSTANTS.GRID_HEIGHT - 4) {
                    zone = 'downtown';
                    basePrice = 8000 + Math.floor(Math.random() * 2000);
                }

                // 3. Industrial (Vertical Strip)
                else if (x >= 4 && x <= 6 && y < CONSTANTS.GRID_HEIGHT - 4) {
                    zone = 'industrial';
                    basePrice = 4000 + Math.floor(Math.random() * 1000);
                }

                // 4. Suburbs (Default, Top Left)
                else {
                    if(type !== 'water') {
                        zone = 'suburbs';
                        basePrice = 2000 + Math.floor(Math.random() * 1000);
                    }
                }

                // 5. Road Network (Simple Cross)
                if (type !== 'water' && (x === 10 || y === 7)) {
                    type = 'road';
                    basePrice *= 1.1;
                }

                this.grid[x][y] = {
                    x, y,
                    type: type,
                    zone: zone,
                    owner: null,
                    building: null,
                    price: Math.floor(basePrice),
                    appeal: 50
                };
            }
        }
        // Initialize some rival land
        this.grid[CONSTANTS.GRID_WIDTH - 2][CONSTANTS.GRID_HEIGHT - 5].owner = 'rival';
        this.grid[CONSTANTS.GRID_WIDTH - 3][CONSTANTS.GRID_HEIGHT - 5].owner = 'rival';
    }

    startNewGame() {
        this.initGrid();
        this.cash = 50000;
        this.loan = 0;
        this.netWorth = 50000;
        this.week = 1;
        this.year = 1;
        this.marketIndex = 100;
        this.marketMultiplier = 1.0;
        this.services = { police: false, fire: false };
        this.achievementsUnlocked = [];
        this.log("New game started.", "trend-up");
        this.ui.updateServices();
        this.ui.updateStats();
        this.hideMenu();
    }

    hideMenu() {
         document.getElementById('main-menu-overlay').style.display = 'none';
         this.setSpeed(1); // Start the clock
    }

    saveGame() {
        const saveData = {
            cash: this.cash,
            loan: this.loan,
            week: this.week,
            year: this.year,
            marketTrend: this.marketTrend,
            marketIndex: this.marketIndex,
            services: this.services,
            grid: this.grid,
            achievementsUnlocked: this.achievementsUnlocked
        };
        try {
            localStorage.setItem('metroMogulSave', JSON.stringify(saveData));
            document.getElementById('ui-save-status').textContent = "Saved";
            setTimeout(() => document.getElementById('ui-save-status').textContent = "", 2000);
            this.updateLoadButton();
        } catch(e) {
            console.error("Save failed", e);
        }
    }

    loadGame() {
        const saved = localStorage.getItem('metroMogulSave');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                this.cash = data.cash;
                this.loan = data.loan;
                this.week = data.week;
                this.year = data.year;
                this.marketTrend = data.marketTrend || 'Normal';
                this.marketIndex = data.marketIndex || 100;
                this.marketMultiplier = this.marketIndex / 100;
                this.grid = data.grid;
                this.services = data.services || { police: false, fire: false };
                this.achievementsUnlocked = data.achievementsUnlocked || [];

                this.log("Game Loaded.", "trend-flat");
                this.ui.updateServices();
                this.ui.updateStats();
                this.hideMenu();
                return true;
            } catch(e) {
                console.error("Load failed", e);
                this.log("Load failed. Starting new game.", "trend-down");
                this.startNewGame();
                return false;
            }
        }
        this.log("No save game found.", "trend-down");
        return false;
    }

    resetGame() {
        if(confirm("Are you sure? This will wipe your save and reload the game.")) {
            localStorage.removeItem('metroMogulSave');
            location.reload();
        }
    }

    // --- Core Logic ---

    gameLoop(timestamp) {
        // Visual updates independent of game speed (Day/Night)
        this.dayCycle = (this.dayCycle + 0.1) % 100;

        // Weather Animation
        if (this.weather === 'rain') {
            this.drawRain();
        }

        if (this.speed > 0) {
            let interval = CONSTANTS.BASE_TICK_RATE / this.speed;
            if (timestamp - this.lastTickTime > interval) {
                this.tick();
                this.lastTickTime = timestamp;
            }
        }

        this.updateFloatingTexts();
        this.draw();
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    setSpeed(s) {
        this.speed = s;
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        if(s===0) document.getElementById('btn-pause').classList.add('active');
        if(s===1) document.getElementById('btn-normal').classList.add('active');
        if(s===4) document.getElementById('btn-fast').classList.add('active');
    }

    toggleAppealView() {
        if (this.viewMode === 'normal') {
            this.viewMode = 'appeal';
            document.getElementById('btn-view-appeal').classList.add('active');
            this.log("Appeal Heatmap ON.");
        } else {
            this.viewMode = 'normal';
            document.getElementById('btn-view-appeal').classList.remove('active');
            this.log("Appeal Heatmap OFF.");
        }
    }

    // Zoom Functions
    adjustZoom(delta) {
        this.zoom = Math.max(0.5, Math.min(2.5, this.zoom + delta));
        this.log(`Zoom: ${Math.round(this.zoom*100)}%`);
    }
    resetZoom() { this.zoom = 1.0; }

    tick() {
        if (this.grid.length === 0) return;

        this.week++;
        if (this.week > 52) {
            this.week = 1;
            this.annualEvents();
        }

        // Weather Logic
        if (Math.random() < 0.05) { // 5% chance to change weather
            this.weather = (this.weather === 'clear') ? 'rain' : 'clear';
            if(this.weather === 'rain') this.log("It started raining.", "trend-down");
            else this.log("The skies have cleared.", "trend-up");
            document.getElementById('ui-weather').textContent = this.weather === 'rain' ? 'Rain üåßÔ∏è' : 'Clear ‚òÄÔ∏è';
        }

        this.saveGame();

        // 1. Market Volatility
        let volatility = Math.random() * 0.5 - 0.25;
        this.marketIndex = Math.max(50, Math.min(150, this.marketIndex + volatility));
        this.marketMultiplier = this.marketIndex / 100;
        this.changeMarketState();

        // 2. Events & Rival
        this.handleRandomEvents();
        const rivalChance = this.services.police ? 0.05 : 0.15;
        if (Math.random() < rivalChance) this.rivalAction();

        // 3. Finances
        let weeklyGrossIncome = 0;
        let weeklyExpenses = 0;
        let weeklyTaxableRent = 0;

        // Interest
        let interest = Math.ceil((this.loan * 0.05) / 52);
        weeklyExpenses += interest;

        // Service Costs
        if (this.services.police) weeklyExpenses += CONSTANTS.SERVICE_COSTS.police;
        if (this.services.fire) weeklyExpenses += CONSTANTS.SERVICE_COSTS.fire;

        const decayReduction = this.services.fire ? 0.5 : 1.0;
        const weatherMaintPenalty = this.weather === 'rain' ? 1.5 : 1.0; // Rain increases maintenance

        for (let col of this.grid) {
            for (let tile of col) {
                this.updateTileAppeal(tile);

                if (tile.owner === 'player' && tile.building) {

                    // Maintenance Logic
                    let maint = tile.building.maintenance * weatherMaintPenalty;
                    weeklyExpenses += maint;

                    // Income Logic
                    if (tile.building.stats.type !== 'amenity' && tile.building.stats.type !== 'transport') {
                        let conditionMultiplier = tile.building.condition / 100;
                        let rent = tile.building.baseRent * tile.building.level * (tile.appeal / 50) * conditionMultiplier * this.marketMultiplier;

                        // Night time reduces shop income
                        if (this.dayCycle > 75 && tile.building.stats.type.includes('com')) {
                             rent *= 0.2; // Shops closed at night
                        }

                        let occupancy = 1.0;
                        if (tile.building.stats.type.includes('_high') && tile.appeal < 40) occupancy = 0.6;
                        if (tile.building.stats.type === 'ind') occupancy = 1.0;
                        if (tile.building.condition < 40) occupancy *= 0.5;

                        let actualRent = rent * occupancy;
                        weeklyGrossIncome += actualRent;
                        weeklyTaxableRent += actualRent;

                        if (Math.random() < 0.02) {
                            this.spawnFloatingText(`+$${Math.floor(actualRent)}`, tile.x, tile.y, '#2ecc71');
                        }
                    }

                    // Condition Decay
                    let decayRate = tile.building.stats.type.includes('_high') ? 1.0 : 0.5;
                    tile.building.condition -= decayRate * decayReduction * weatherMaintPenalty;
                    if(tile.building.condition < 0) tile.building.condition = 0;
                }

                // Rival buildings decay
                if(tile.owner === 'rival' && tile.building) {
                    let decayRate = tile.building.stats.type.includes('_high') ? 1.0 : 0.5;
                    tile.building.condition -= decayRate;
                    if(tile.building.condition < 0) tile.building.condition = 0;
                }
            }
        }

        let incomeTax = Math.floor(weeklyTaxableRent * CONSTANTS.CITY_TAX_RATE);
        weeklyExpenses += incomeTax;

        this.cash += (weeklyGrossIncome - weeklyExpenses);

        let netProfit = weeklyGrossIncome - weeklyExpenses;
        this.ui.updateStats(netProfit, incomeTax);
        this.checkAchievements();

        if (this.selectedTile) this.ui.renderSelection(this.selectedTile);

        if (this.cash < -50000) {
            alert("BANKRUPT! Your debt is too high. Game will reset.");
            this.resetGame();
        }
    }

    checkAchievements() {
        CONSTANTS.ACHIEVEMENTS.forEach(ach => {
            if (!this.achievementsUnlocked.includes(ach.id)) {
                if (this.netWorth >= ach.threshold) {
                    this.achievementsUnlocked.push(ach.id);
                    this.cash += ach.reward;
                    this.ui.showAchievement(ach);
                    this.log(`Achievement: ${ach.name}! Bonus: $${ach.reward}`, "trend-up");
                }
            }
        });
    }

    handleRandomEvents() {
        // Fire Event (Less likely in rain)
        let fireChance = this.weather === 'rain' ? 0.005 : 0.02;
        if (Math.random() < fireChance) {
            let playerTiles = [];
            this.grid.forEach(c => c.forEach(t => { if(t.owner === 'player' && t.building) playerTiles.push(t) }));

            if (playerTiles.length > 0) {
                let victim = playerTiles[Math.floor(Math.random() * playerTiles.length)];
                if (this.services.fire) {
                     this.log(`Fire extinguished at ${victim.building.name}! Service did its job.`);
                } else {
                     victim.building.condition = 0;
                     this.log(`üî• FIRE at ${victim.building.name}! Condition ruined! Build a Fire Station!`, 'trend-down');
                     this.spawnFloatingText("FIRE!", victim.x, victim.y, '#e74c3c');
                }
            }
        }

        // Crime Event
        if (Math.random() < 0.03) {
             if (this.services.police) {
                 // Prevented
             } else {
                 let stolen = Math.floor(this.cash * 0.05);
                 if (stolen > 500) {
                     this.cash -= stolen;
                     this.log(`üëÆ Crime Wave! Thieves stole $${stolen}. Build a Police Station!`, 'trend-down');
                 }
             }
        }
    }

    changeMarketState() {
        const oldTrend = this.marketTrend;
        let push = 0;

        if (this.marketIndex > 130) {
            this.marketTrend = 'Boom';
            push = 5;
        } else if (this.marketIndex < 70) {
            this.marketTrend = 'Recession';
            push = -5;
        } else {
            this.marketTrend = 'Normal';
        }

        if (Math.random() < 0.01) {
            push += (Math.random() > 0.5 ? 10 : -10);
        }

        this.marketIndex = Math.max(50, Math.min(150, this.marketIndex + push));
        this.marketMultiplier = this.marketIndex / 100;

        if (this.marketTrend !== oldTrend) {
            this.ui.updateTicker();
        }
    }

    rivalAction() {
        let rivalsLand = [];
        let emptyLand = [];

        for (let x = 0; x < CONSTANTS.GRID_WIDTH; x++) {
            for (let y = 0; y < CONSTANTS.GRID_HEIGHT; y++) {
                let t = this.grid[x][y];
                if (t.owner === 'rival' && !t.building) rivalsLand.push(t);
                if (t.owner === null && t.type !== 'water' && t.type !== 'road') emptyLand.push(t);
            }
        }

        // Action 1: Build
        if (rivalsLand.length > 0 && Math.random() < 0.7) {
            let t = rivalsLand[Math.floor(Math.random() * rivalsLand.length)];
            let type = 'residential';
            if (t.zone === 'downtown') {
                if (t.appeal > 80) type = 'office';
                else type = 'apartment';
            } else if (t.zone === 'industrial') {
                type = 'factory';
            }

            let bData = CONSTANTS.BUILDING_TYPES[type];
            // Rival obeys zoning vaguely (simple AI)
            if (!bData.allowed.includes(t.zone)) return;

            t.building = {
                type: type,
                name: "Rival " + bData.name,
                level: 1,
                condition: 100,
                baseRent: bData.baseRent,
                maintenance: bData.maintenance,
                stats: bData,
                color: CONSTANTS.COLORS.rivalBuilding
            };
            this.spawnFloatingText("RIVAL BUILD", t.x, t.y, '#555');
        }
        // Action 2: Buy
        else if (emptyLand.length > 0) {
            let t = emptyLand[Math.floor(Math.random() * emptyLand.length)];
            t.owner = 'rival';
            this.log(`Rival bought land at (${t.x},${t.y})`);
            this.spawnFloatingText("SOLD!", t.x, t.y, '#e74c3c');
        }
    }

    spawnFloatingText(text, tx, ty, color) {
        this.floatingTexts.push({
            text,
            x: tx * CONSTANTS.TILE_SIZE + CONSTANTS.TILE_SIZE/2,
            y: ty * CONSTANTS.TILE_SIZE,
            life: 60, // frames
            color: color
        });
    }

    updateFloatingTexts() {
        for(let i = this.floatingTexts.length - 1; i >= 0; i--) {
            let ft = this.floatingTexts[i];
            ft.y -= 0.5; // float up
            ft.life--;
            if(ft.life <= 0) this.floatingTexts.splice(i, 1);
        }
    }

    updateTileAppeal(tile) {
        let baseAppeal = 50;

        // Global Police Bonus
        if (this.services.police) {
            baseAppeal += 5;
        }

        const range = 4;
        for (let dx = -range; dx <= range; dx++) {
            for (let dy = -range; dy <= range; dy++) {
                let nx = tile.x + dx;
                let ny = tile.y + dy;
                if (this.isValidTile(nx, ny)) {
                    let neighbor = this.grid[nx][ny];
                    let dist = Math.max(Math.abs(dx), Math.abs(dy));

                    // General Building/Amenity Modifiers
                    if (neighbor.building) {
                        // Park bonus
                        if (neighbor.building.type === 'park') {
                            let bonus = neighbor.building.stats.appealBonus / (dist || 1);
                            baseAppeal += bonus;
                        }
                        // Factory Pollution
                        if (neighbor.building.type === 'factory') {
                            let penalty = 20 / (dist || 1);
                            baseAppeal -= penalty;
                        }
                        // Metro Boost (Does not affect appeal directly, but good for gameplay logic if expanded)
                        if (neighbor.building.type === 'metro') {
                            baseAppeal += (10 / (dist || 1));
                        }

                        if (neighbor.building.condition < 40) baseAppeal -= 5;
                        if (neighbor.building.stats.type === 'com_high' || neighbor.owner === 'rival') {
                             if(dist < 2) baseAppeal -= 2;
                        }
                    }

                    // Zone/Terrain Modifiers
                    if (neighbor.type === 'water') baseAppeal += (8 / (dist || 1));
                    if (neighbor.type === 'road' && dist < 2) baseAppeal += 2;
                    if (neighbor.zone === 'industrial' && dist < 3) baseAppeal -= 10;
                }
            }
        }
        tile.appeal = Math.min(100, Math.max(0, Math.floor(baseAppeal)));
    }

    isValidTile(x, y) {
        return x >= 0 && x < CONSTANTS.GRID_WIDTH && y >= 0 && y < CONSTANTS.GRID_HEIGHT;
    }

    annualEvents() {
        this.log(`--- YEAR ${this.year} ENDED ---`);
        const PROPERTY_TAX_RATE = 0.015;
        let totalAssetValue = 0;

        for (let col of this.grid) {
            for (let t of col) {
                if(t.owner === 'player') {
                    totalAssetValue += t.price * this.marketMultiplier;
                    if(t.building) totalAssetValue += t.building.stats.cost;
                }
            }
        }

        let tax = Math.floor(totalAssetValue * PROPERTY_TAX_RATE);
        this.cash -= tax;
        this.log(`Annual Property Tax Paid: -$${tax.toLocaleString()}`, "trend-down");
        this.year++;
        this.log(`Year ${this.year} begun.`, "trend-flat");
    }

    // --- Actions ---

    actions = {
        buyLand: () => {
            if (!this.selectedTile) return;
            let cost = this.selectedTile.price * this.marketMultiplier;
            if (this.cash >= cost) {
                this.cash -= cost;
                this.selectedTile.owner = 'player';
                this.log(`Bought land for $${Math.floor(cost)}`);
                this.spawnFloatingText("-$" + Math.floor(cost), this.selectedTile.x, this.selectedTile.y, '#e74c3c');
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            } else {
                this.log("Not enough cash!", "trend-down");
            }
        },

        sellLand: () => {
            if (!this.selectedTile || this.selectedTile.owner !== 'player') return;

            // Selling logic: 75% of land value + 50% of building cost
            let landVal = this.selectedTile.price * this.marketMultiplier * 0.75;
            let buildVal = this.selectedTile.building ? this.selectedTile.building.stats.cost * 0.5 : 0;
            let total = Math.floor(landVal + buildVal);

            if(confirm(`Sell this land and property for $${total.toLocaleString()}?`)) {
                this.cash += total;
                this.selectedTile.owner = null;
                this.selectedTile.building = null;
                this.log(`Sold property for $${total}`);
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            }
        },

        takeover: () => {
            if (!this.selectedTile || this.selectedTile.owner !== 'rival') return;
            let landCost = this.selectedTile.price * this.marketMultiplier * 2.5;
            let buildCost = this.selectedTile.building ? this.selectedTile.building.stats.cost * 2 : 0;
            let total = Math.floor(landCost + buildCost);

            if (this.cash >= total) {
                this.cash -= total;
                this.selectedTile.owner = 'player';
                if(this.selectedTile.building) {
                    this.selectedTile.building.color = this.selectedTile.building.stats.color;
                    this.selectedTile.building.name = this.selectedTile.building.stats.name;
                    this.selectedTile.building.condition = Math.min(100, this.selectedTile.building.condition + 30);
                }
                this.log(`Hostile Takeover successful! (-$${total})`);
                this.spawnFloatingText("TAKEOVER!", this.selectedTile.x, this.selectedTile.y, '#f1c40f');
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            } else {
                this.log(`Need $${total} for takeover.`, "trend-down");
            }
        },

        takeLoan: () => {
            this.cash += 10000;
            this.loan += 10000;
            this.log("Borrowed $10,000.");
            this.ui.updateStats();
        },

        repayLoan: () => {
            if(this.loan >= 10000 && this.cash >= 10000) {
                this.cash -= 10000;
                this.loan -= 10000;
                this.log("Repaid $10,000.");
                this.ui.updateStats();
            } else {
                this.log("Cannot repay loan.", "trend-down");
            }
        },

        openBuildMenu: () => {
            this.ui.showBuildMenu();
        },

        build: (type) => {
            if (!this.selectedTile) return;
            if (this.selectedTile.type === 'road') {
                this.log("Cannot build on road.", "trend-down");
                return;
            }

            let bData = CONSTANTS.BUILDING_TYPES[type];
            if (!bData.allowed.includes(this.selectedTile.zone)) {
                this.log(`ZONING ERROR: ${bData.name} not allowed in ${this.selectedTile.zone.toUpperCase()}.`, "trend-down");
                return;
            }

            let cost = bData.cost;
            if (this.cash >= cost) {
                this.cash -= cost;
                this.selectedTile.building = {
                    type: type,
                    name: bData.name,
                    level: 1,
                    condition: 100,
                    maintenance: bData.maintenance,
                    baseRent: bData.baseRent,
                    stats: bData,
                    color: bData.color
                };
                this.log(`Built ${bData.name} for $${cost}`);
                this.spawnFloatingText("BUILT!", this.selectedTile.x, this.selectedTile.y, '#f1c40f');
                this.ui.closeBuildMenu();
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            } else {
                this.log("Insufficient funds.", "trend-down");
            }
        },

        renovate: () => {
            if (!this.selectedTile || !this.selectedTile.building) return;
            let b = this.selectedTile.building;
            let cost = 1000 * b.level;

            if (b.condition === 100) return;

            if (this.cash >= cost) {
                this.cash -= cost;
                b.condition = 100;
                this.log("Renovated building.");
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            } else {
                this.log(`Need $${cost} to renovate.`);
            }
        },

        upgrade: () => {
            if (!this.selectedTile || !this.selectedTile.building) return;
            let b = this.selectedTile.building;
            let cost = b.stats.cost * (b.level + 1) * 0.8;

            if (b.level >= 5) {
                this.log("Max level reached.");
                return;
            }

            if (this.cash >= cost) {
                this.cash -= cost;
                b.level++;
                b.condition = 100;
                this.log(`Upgraded to Level ${b.level}!`);
                this.spawnFloatingText("LVL UP!", this.selectedTile.x, this.selectedTile.y, '#2ecc71');
                this.ui.renderSelection(this.selectedTile);
                this.ui.updateStats();
            } else {
                this.log(`Need $${cost} to upgrade.`);
            }
        },

        demolish: () => {
             if (!this.selectedTile || !this.selectedTile.building) return;
             if(confirm("Demolish building?")) {
                 let scrapValue = 1000;
                 this.cash += scrapValue;
                 this.selectedTile.building = null;
                 this.log(`Demolished.`);
                 this.ui.renderSelection(this.selectedTile);
                 this.ui.updateStats();
             }
        },

        toggleService: (serviceName) => {
            this.services[serviceName] = !this.services[serviceName];
            if (this.services[serviceName]) {
                this.log(`Activated ${serviceName.toUpperCase()}.`);
            } else {
                this.log(`Deactivated ${serviceName.toUpperCase()}.`);
            }
            this.ui.updateServices();
            this.ui.updateStats();
        }
    };

    // --- Rendering ---

    resize() {
        this.width = document.getElementById('viewport').offsetWidth;
        this.height = document.getElementById('viewport').offsetHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }

    draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);

        this.ctx.save();

        // --- 1. ZOOM & CAMERA TRANSFORMATIONS ---

        // Translate to Center
        this.ctx.translate(this.width/2, this.height/2);
        // Apply Scale
        this.ctx.scale(this.zoom, this.zoom);
        // Translate back
        this.ctx.translate(-this.width/2, -this.height/2);

        // Apply Camera offset centered relative to grid size
        let cx = this.camera.x + this.width/2 - (CONSTANTS.GRID_WIDTH * CONSTANTS.TILE_SIZE)/2;
        let cy = this.camera.y + this.height/2 - (CONSTANTS.GRID_HEIGHT * CONSTANTS.TILE_SIZE)/2;
        this.ctx.translate(cx, cy);

        // --- 2. WORLD RENDERING ---

        // Draw Tiles
        for (let x = 0; x < CONSTANTS.GRID_WIDTH; x++) {
            for (let y = 0; y < CONSTANTS.GRID_HEIGHT; y++) {
                if (this.grid[x] && this.grid[x][y]) {
                    this.drawTile(this.grid[x][y], x * CONSTANTS.TILE_SIZE, y * CONSTANTS.TILE_SIZE);
                }
            }
        }

        // Draw Floating Text (in world space)
        this.ctx.font = "bold 20px VT323";
        this.ctx.textAlign = "center";
        for(let ft of this.floatingTexts) {
            this.ctx.fillStyle = ft.color;
            this.ctx.strokeStyle = "black";
            this.ctx.lineWidth = 2;
            this.ctx.strokeText(ft.text, ft.x, ft.y);
            this.ctx.fillText(ft.text, ft.x, ft.y);
        }

        // Selection Box
        if (this.selectedTile) {
            this.ctx.strokeStyle = '#f1c40f';
            this.ctx.lineWidth = 4;
            this.ctx.strokeRect(this.selectedTile.x * CONSTANTS.TILE_SIZE, this.selectedTile.y * CONSTANTS.TILE_SIZE, CONSTANTS.TILE_SIZE, CONSTANTS.TILE_SIZE);
        }

        // Hover Box
        if (this.hoverTile) {
            this.ctx.fillStyle = CONSTANTS.COLORS.hover;
            this.ctx.fillRect(this.hoverTile.x * CONSTANTS.TILE_SIZE, this.hoverTile.y * CONSTANTS.TILE_SIZE, CONSTANTS.TILE_SIZE, CONSTANTS.TILE_SIZE);
        }

        // --- 3. NIGHT MODE OVERLAY ---
        if (this.dayCycle > 75) { // Night time
            this.ctx.fillStyle = 'rgba(10, 10, 60, 0.4)'; // Dark Blue Tint
            this.ctx.fillRect(-1000, -1000, 4000, 4000); // Cover the world
        }

        this.ctx.restore();
    }

    drawRain() {
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(174, 194, 224, 0.5)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let i=0; i<100; i++) {
            let rx = Math.random() * this.width;
            let ry = Math.random() * this.height;
            this.ctx.moveTo(rx, ry);
            this.ctx.lineTo(rx - 5, ry + 15);
        }
        this.ctx.stroke();
        this.ctx.restore();
    }

    drawTile(tile, sx, sy) {
        let size = CONSTANTS.TILE_SIZE;
        let isNight = this.dayCycle > 75;

        // 1. Base Terrain & Zone Color
        if (tile.type === 'water') {
            this.ctx.fillStyle = CONSTANTS.COLORS.water;
        } else if (tile.type === 'road') {
             this.ctx.fillStyle = CONSTANTS.COLORS.road;
             this.ctx.fillRect(sx, sy, size, size);
             this.ctx.fillStyle = '#fff';
             this.ctx.fillRect(sx + size/2 - 2, sy + 5, 4, 15);
             this.ctx.fillRect(sx + size/2 - 2, sy + size - 20, 4, 15);
             this.ctx.fillRect(sx + 5, sy + size/2 - 2, 15, 4);
             this.ctx.fillRect(sx + size - 20, sy + size/2 - 2, 15, 4);
             return;
        } else {
             if (tile.zone === 'downtown') this.ctx.fillStyle = CONSTANTS.COLORS.grass_downtown;
             else if (tile.zone === 'industrial') this.ctx.fillStyle = CONSTANTS.COLORS.grass_industrial;
             else this.ctx.fillStyle = CONSTANTS.COLORS.grass_suburb;
        }
        this.ctx.fillRect(sx, sy, size, size);

        // 2. Heatmap Overlay
        if (this.viewMode === 'appeal' && tile.type !== 'water') {
            let alpha = tile.appeal / 100;
            if (tile.appeal > 50) this.ctx.fillStyle = `rgba(46, 204, 113, ${alpha * 0.8})`;
            else this.ctx.fillStyle = `rgba(231, 76, 60, ${(1-alpha) * 0.3})`;
            this.ctx.fillRect(sx, sy, size, size);
        }

        // 3. Grid Lines
        this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(sx, sy, size, size);

        // 4. Buildings
        if (tile.building) {
            let b = tile.building;
            let padding = 10;
            let buildW = size - padding*2;
            let buildH = size - padding*2;

            // Draw Main Block
            this.ctx.fillStyle = b.color;
            this.ctx.fillRect(sx + padding, sy + padding + 10, buildW, buildH - 10);

            // Detail based on type
            if (b.stats.type === 'res') { // House
                this.ctx.beginPath();
                this.ctx.moveTo(sx + padding, sy + padding + 10);
                this.ctx.lineTo(sx + size/2, sy + padding - 5);
                this.ctx.lineTo(sx + size - padding, sy + padding + 10);
                this.ctx.fillStyle = '#c0392b';
                this.ctx.fill();

                // Windows (Lit at night)
                this.ctx.fillStyle = isNight ? '#f1c40f' : '#888';
                this.ctx.fillRect(sx + padding + 5, sy + padding + 20, 8, 8);

                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(sx + size/2 - 5, sy + size - 15, 10, 15);
            }
            else if (b.stats.type === 'res_high') { // Apartments
                for(let r=0; r<3; r++) {
                    // Windows Lit at night randomly
                    this.ctx.fillStyle = (isNight && Math.random()>0.3) ? '#f1c40f' : '#ccc';
                    this.ctx.fillRect(sx+padding+4, sy+padding+14+(r*10), 8, 6);
                    this.ctx.fillStyle = (isNight && Math.random()>0.3) ? '#f1c40f' : '#ccc';
                    this.ctx.fillRect(sx+padding+16, sy+padding+14+(r*10), 8, 6);
                    this.ctx.fillStyle = (isNight && Math.random()>0.3) ? '#f1c40f' : '#ccc';
                    this.ctx.fillRect(sx+padding+28, sy+padding+14+(r*10), 8, 6);
                }
            }
            else if (b.stats.type === 'com') { // Shop
                this.ctx.fillStyle = '#e67e22'; // Awning
                this.ctx.beginPath();
                this.ctx.moveTo(sx + padding, sy + padding + 15);
                this.ctx.lineTo(sx + padding + 5, sy + padding + 25);
                this.ctx.lineTo(sx + padding + 10, sy + padding + 15);
                this.ctx.lineTo(sx + padding + 15, sy + padding + 25);
                this.ctx.lineTo(sx + padding + 20, sy + padding + 15);
                this.ctx.lineTo(sx + padding + 25, sy + padding + 25);
                this.ctx.lineTo(sx + padding + 30, sy + padding + 15);
                this.ctx.lineTo(sx + padding + 35, sy + padding + 25);
                this.ctx.lineTo(sx + size - padding, sy + padding + 15);
                this.ctx.fill();
                // Storefront
                this.ctx.fillStyle = (isNight) ? '#222' : '#85c1e9'; // Dark at night (closed)
                this.ctx.fillRect(sx+padding+5, sy+padding+25, buildW-10, buildH-25);
            }
            else if (b.stats.type === 'com_high') { // Office
                this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                this.ctx.beginPath();
                this.ctx.moveTo(sx + padding, sy + size - padding);
                this.ctx.lineTo(sx + size - padding, sy + padding + 10);
                this.ctx.lineTo(sx + size - padding, sy + size - padding);
                this.ctx.fill();
            }
            else if (b.stats.type === 'ind') { // Factory
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(sx + size - 20, sy + 5, 10, 20);
                if (Math.random() > 0.5) { // Smoke
                    this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    this.ctx.beginPath();
                    this.ctx.arc(sx + size - 15, sy + 2, 5, 0, Math.PI*2);
                    this.ctx.fill();
                }
            }
            else if (b.stats.type === 'transport') { // Metro
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(sx + padding + 5, sy + padding + 20, 24, 20);
                this.ctx.fillStyle = '#f1c40f'; // M logo
                this.ctx.font = '20px Arial';
                this.ctx.fillText("M", sx + size/2, sy + size/2 + 5);
            }
            else if (b.stats.type === 'amenity') { // Park
                this.ctx.fillStyle = '#27ae60';
                this.ctx.beginPath();
                this.ctx.arc(sx+size/2, sy+size/2, 12, 0, Math.PI*2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(sx+size/2-8, sy+size/2+5, 8, 0, Math.PI*2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(sx+size/2+8, sy+size/2+5, 8, 0, Math.PI*2);
                this.ctx.fill();
            }

            // Rival Marker
            if (tile.owner === 'rival') {
                this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                this.ctx.fillRect(sx+5, sy+size-20, size-10, 15);
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px VT323';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("RIVAL", sx+size/2, sy+size-9);
            }

            // Maintenance Warning
            if(tile.owner === 'player' && b.condition < 40) {
                this.ctx.fillStyle = 'red';
                this.ctx.font = 'bold 24px VT323';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('!', sx+size-5, sy+25);
            }

        } else if (tile.owner === 'player') {
            this.ctx.strokeStyle = '#fff';
            this.ctx.setLineDash([5, 5]);
            this.ctx.strokeRect(sx + 5, sy + 5, size - 10, size - 10);
            this.ctx.setLineDash([]);
        } else if (tile.owner === 'rival') {
            this.ctx.fillStyle = '#444';
            this.ctx.fillRect(sx+5, sy+5, size-10, size-10);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '16px VT323';
            this.ctx.textAlign = 'center';
            this.ctx.fillText("SOLD", sx+size/2, sy+size/2+5);
        } else if (tile.type !== 'water') {
            if(this.viewMode !== 'appeal') {
                let color = this.marketMultiplier > 1.2 ? '#2ecc71' : (this.marketMultiplier < 0.8 ? '#e74c3c' : 'rgba(0,0,0,0.1)');
                this.ctx.fillStyle = color;
                this.ctx.font = 'bold 16px VT323';
                this.ctx.textAlign = 'center';
                let price = Math.floor(tile.price * this.marketMultiplier);
                this.ctx.fillText(`$${price/1000}k`, sx + size/2, sy + size/2 + 5);
            }
        }

        if (tile === this.hoverTile) {
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px VT323';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(tile.zone.toUpperCase(), sx + 4, sy + 12);
        }
    }

    // --- Events ---

    setupEvents() {
        window.addEventListener('resize', () => this.resize());

        // --- ZOOM HANDLER ---
        this.canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            let delta = e.deltaY > 0 ? -0.1 : 0.1;
            this.adjustZoom(delta);
        }, { passive: false });

        const getPos = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        };

        this.canvas.addEventListener('mousedown', (e) => {
            if(this.speed === 0) return;
            this.isDragging = true;
            this.lastMouse = getPos(e);
        });

        window.addEventListener('mouseup', () => this.isDragging = false);

        this.canvas.addEventListener('mousemove', (e) => {
            const mouse = getPos(e);
            if (this.isDragging) {
                // Adjust dragging speed based on zoom level to feel natural
                this.camera.x += (mouse.x - this.lastMouse.x) / this.zoom;
                this.camera.y += (mouse.y - this.lastMouse.y) / this.zoom;
                this.lastMouse = mouse;
            } else {
                this.calculateHover(mouse.x, mouse.y);
            }
        });

        this.canvas.addEventListener('click', (e) => {
            if(this.speed === 0) return;
            if (this.isDragging && Math.abs(e.movementX) > 2) return;
            const mouse = getPos(e);
            this.handleClick(mouse.x, mouse.y);
        });
    }

    screenToGrid(sx, sy) {
        // 1. Center of screen
        let cx = this.width / 2;
        let cy = this.height / 2;

        // 2. Adjust for Zoom (scale around center)
        // (Input ScreenCoord - Center) / Zoom + Center = WorldCoord relative to screen center
        let worldX = (sx - cx) / this.zoom + cx;
        let worldY = (sy - cy) / this.zoom + cy;

        // 3. Grid Dimensions in Pixels
        let gridPixelWidth = CONSTANTS.GRID_WIDTH * CONSTANTS.TILE_SIZE;
        let gridPixelHeight = CONSTANTS.GRID_HEIGHT * CONSTANTS.TILE_SIZE;

        // 4. Calculate Offset used in draw()
        // Draw logic: ctx.translate(cx + camera.x - gridW/2, cy + camera.y - gridH/2)
        // So WorldCoord = GridCoord * TILE_SIZE + Offset
        // GridCoord = (WorldCoord - Offset) / TILE_SIZE

        let drawOffsetX = cx + this.camera.x - gridPixelWidth/2;
        let drawOffsetY = cy + this.camera.y - gridPixelHeight/2;

        let gx = Math.floor((worldX - drawOffsetX) / CONSTANTS.TILE_SIZE);
        let gy = Math.floor((worldY - drawOffsetY) / CONSTANTS.TILE_SIZE);

        if (gx >= 0 && gx < CONSTANTS.GRID_WIDTH && gy >= 0 && gy < CONSTANTS.GRID_HEIGHT) return { x: gx, y: gy };
        return null;
    }

    calculateHover(sx, sy) {
        let gridPos = this.screenToGrid(sx, sy);
        this.hoverTile = gridPos ? this.grid[gridPos.x][gridPos.y] : null;
    }

    handleClick(sx, sy) {
        let gridPos = this.screenToGrid(sx, sy);
        if (gridPos) {
            this.selectedTile = this.grid[gridPos.x][gridPos.y];
            this.ui.renderSelection(this.selectedTile);
            this.ui.closeBuildMenu();
        } else {
            this.selectedTile = null;
            this.ui.renderSelection(null);
        }
    }

    log(msg, className) {
        const logEl = document.getElementById('game-log');
        const entry = document.createElement('div');
        entry.textContent = `> ${msg}`;
        if(className) entry.classList.add(className);
        logEl.prepend(entry);
    }
}

class UIManager {
    constructor(game) {
        this.game = game;
        this.elSelection = document.getElementById('selection-content');
        this.elBuildBtns = document.getElementById('build-buttons');
        this.elPoliceBtn = document.getElementById('service-police');
        this.elFireBtn = document.getElementById('service-fire');
        this.updateServices();
    }

    updateStats(netProfit = 0, incomeTax = 0) {
        const fmt = (n) => `$${Math.floor(n).toLocaleString()}`;

        document.getElementById('ui-cash').textContent = fmt(this.game.cash);
        document.getElementById('ui-loans').textContent = fmt(this.game.loan);
        document.getElementById('hud-money').textContent = fmt(this.game.cash);

        let assetValue = 0;
        if (this.game.grid.length > 0) {
            this.game.grid.forEach(col => col.forEach(t => {
                if(t.owner === 'player') {
                    assetValue += t.price * this.game.marketMultiplier;
                    if(t.building) assetValue += t.building.stats.cost * 0.8;
                }
            }));
        }

        this.game.netWorth = this.game.cash - this.game.loan + assetValue;
        document.getElementById('ui-networth').textContent = fmt(this.game.netWorth);

        let sign = netProfit >= 0 ? '+' : '';
        document.getElementById('ui-income').textContent = `${sign}${fmt(netProfit)} (Tax: ${fmt(incomeTax)})`;
        document.getElementById('ui-income').className = netProfit >= 0 ? 'trend-up' : 'trend-down';

        document.getElementById('ui-date').textContent = `Wk ${this.game.week}, Yr ${this.game.year}`;

        document.getElementById('ui-market').textContent = `${this.game.marketTrend} (${this.game.marketIndex.toFixed(0)}%)`;
        let trendColor = 'trend-flat';
        if(this.game.marketTrend === 'Boom') trendColor = 'trend-up';
        if(this.game.marketTrend === 'Recession') trendColor = 'trend-down';
        document.getElementById('ui-market').className = trendColor;
    }

    updateTicker() {
        let text = "";
        let index = this.game.marketIndex.toFixed(0);
        if(this.game.marketTrend === 'Boom') text = `NEWS: ECONOMY BOOMING! Market Index at ${index}%!`;
        else if(this.game.marketTrend === 'Recession') text = `NEWS: MARKET CRASH! Index hits ${index}%. INVESTORS FEARFUL.`;
        else text = `NEWS: Real Estate Market Stable. Index: ${index}%.`;
        document.getElementById('ticker').textContent = text;
    }

    updateServices() {
        // Police
        if (this.game.services.police) {
            this.elPoliceBtn.classList.add('service-active');
            this.elPoliceBtn.textContent = `üëÆ‚Äç‚ôÇÔ∏è Police ACTIVE (-$${CONSTANTS.SERVICE_COSTS.police}/wk)`;
        } else {
            this.elPoliceBtn.classList.remove('service-active');
            this.elPoliceBtn.textContent = `üëÆ‚Äç‚ôÇÔ∏è Police ($${CONSTANTS.SERVICE_COSTS.police}/wk)`;
        }

        // Fire
        if (this.game.services.fire) {
            this.elFireBtn.classList.add('service-active');
            this.elFireBtn.textContent = `üöí Fire ACTIVE (-$${CONSTANTS.SERVICE_COSTS.fire}/wk)`;
        } else {
            this.elFireBtn.classList.remove('service-active');
            this.elFireBtn.textContent = `üöí Fire ($${CONSTANTS.SERVICE_COSTS.fire}/wk)`;
        }
    }

    showAchievement(ach) {
        const el = document.getElementById('achievement-popup');
        const txt = document.getElementById('ach-text');
        txt.textContent = ach.name;
        el.style.display = 'block';
        setTimeout(() => { el.style.display = 'none'; }, 4000);
    }

    renderSelection(tile) {
        if (!tile) {
            this.elSelection.innerHTML = '<p style="text-align:center; color:#666;">Select a tile to interact.</p>';
            return;
        }

        let html = `<h3>Coords: (${tile.x}, ${tile.y})</h3>`;
        html += `<div class="stat-row"><span>Zone:</span> <span>${tile.zone.toUpperCase()}</span></div>`;
        html += `<div class="stat-row"><span>Appeal:</span> <span>${tile.appeal}/100</span></div>`;

        if (tile.type === 'water') {
            html += '<p>Cannot build on water.</p>';
        } else if (tile.owner === 'rival') {
            // Rival Owned View
            html += `<p style="color:red; text-align:center; font-weight:bold;">OWNED BY RIVAL</p>`;
            if (tile.building) {
                 html += `<div class="panel-header" style="background:#444; margin-top:10px;">${tile.building.name}</div>`;
                 html += `<div class="stat-row"><span>Condition:</span> <span style="color:${tile.building.condition < 40 ? 'red':'inherit'}">${Math.floor(tile.building.condition)}%</span></div>`;
            }
            // Takeover logic
            let landCost = tile.price * this.game.marketMultiplier * 2.5;
            let buildCost = tile.building ? tile.building.stats.cost * 2 : 0;
            let total = Math.floor(landCost + buildCost);

            html += `<hr>`;
            html += `<p style="font-size:0.9rem;">Hostile Takeover (2.5x Price)</p>`;
            html += `<button class="warning" onclick="Game.actions.takeover()">BUYOUT ($${total.toLocaleString()})</button>`;

        } else if (tile.owner === null) {
            let cost = Math.floor(tile.price * this.game.marketMultiplier);
            html += `<div class="stat-row"><span>Price:</span> <span>$${cost.toLocaleString()}</span></div>`;
            if (tile.type === 'road') {
                html += `<p style="color:#d63031; font-size: 0.9rem;">(Road tile. Cannot buy or build.)</p>`;
            } else {
                html += `<button class="primary" onclick="Game.actions.buyLand()">BUY LAND</button>`;
            }
        } else if (tile.owner === 'player') {
            if (!tile.building) {
                html += `<p>Empty Lot.</p>`;
                html += `<button class="primary" onclick="Game.actions.openBuildMenu()">BUILD...</button>`;
                html += `<button class="warning" onclick="Game.actions.sellLand()" style="margin-top:5px">SELL LAND</button>`;
            } else {
                let b = tile.building;
                html += `<div class="panel-header" style="background:${b.color}; margin-top:10px;">${b.name} (Lvl ${b.level})</div>`;

                let conditionColor = b.condition < 40 ? 'red' : (b.condition < 70 ? '#f1c40f' : '#2ecc71');
                html += `<div class="stat-row"><span>Condition:</span> <span style="color:${conditionColor}">${Math.floor(b.condition)}%</span></div>`;

                if (b.type !== 'park' && b.type !== 'transport') {
                    let conditionMultiplier = b.condition / 100;
                    let currentRent = Math.floor(b.baseRent * b.level * (tile.appeal/50) * conditionMultiplier * this.game.marketMultiplier);
                    html += `<div class="stat-row"><span>Est. Rent:</span> <span>$${currentRent}/wk</span></div>`;
                    html += `<div class="stat-row"><span>Maint. Cost:</span> <span>$${b.maintenance}/wk</span></div>`;
                }

                html += `<hr>`;
                let renoCost = 1000 * b.level;
                let renoDisabled = b.condition === 100 ? 'disabled' : '';
                let renoLabel = b.condition === 100 ? 'Already Perfect' : `Renovate ($${renoCost.toLocaleString()})`;

                html += `<button ${renoDisabled} onclick="Game.actions.renovate()">${renoLabel}</button>`;
                html += `<button onclick="Game.actions.upgrade()">Upgrade</button>`;
                html += `<button class="danger" onclick="Game.actions.sellLand()">SELL PROPERTY</button>`;
            }
        }
        this.elSelection.innerHTML = html;
    }

    showBuildMenu() {
        let html = '';
        const types = Object.values(CONSTANTS.BUILDING_TYPES);

        types.forEach(type => {
            let isLocked = this.game.netWorth < type.unlock;
            let clickAction = isLocked ? '' : `onclick="Game.actions.build('${type.id}')"`;
            let hint = isLocked ? `<span class="locked-hint">Unlock at $${type.unlock.toLocaleString()} Net Worth</span>` : '';

            // Show zoning warning if not allowed
            let zoneWarning = '';
            if (!isLocked && this.game.selectedTile && !type.allowed.includes(this.game.selectedTile.zone)) {
                zoneWarning = `<span style="color:#e74c3c; font-size:0.8rem;">(Not allowed in ${this.game.selectedTile.zone})</span>`;
            }

            html += `<button ${isLocked ? 'disabled' : ''} ${clickAction}>${type.icon} ${type.name} ($${(type.cost/1000).toLocaleString()}k) ${zoneWarning}</button>`;
            if(isLocked) html += hint;
            else html += `<div class="stat-row"><small>${this.getDesc(type.id)}</small></div>`;
        });

        this.elBuildBtns.innerHTML = html;
        document.getElementById('action-panel').style.display = 'none';
        document.getElementById('build-menu').style.display = 'block';
    }

    getDesc(id) {
        if(id === 'residential') return "Low rent, stable, low decay.";
        if(id === 'commercial') return "Needs foot traffic, moderate decay.";
        if(id === 'park') return "Boosts nearby value, low maintenance.";
        if(id === 'apartment') return "High density residential, high decay.";
        if(id === 'office') return "Massive profits, very high decay.";
        if(id === 'factory') return "Big money, creates pollution.";
        if(id === 'metro') return "Boosts nearby Shop/Office rent.";
        return "";
    }

    closeBuildMenu() {
        document.getElementById('build-menu').style.display = 'none';
        document.getElementById('action-panel').style.display = 'block';
    }
}

const Game = new GameEngine();

</script>
</body>
</html>